# Completing Unified setup.py Implementation

This guide outlines the remaining work to complete the unified setup.py for AWS EKS and Azure AKS deployments.

## ✅ What's Already Implemented

### 1. Multi-Cloud Foundation (100%)
- ✅ Cloud provider selection (CLI arg `--cloud-provider` or interactive menu)
- ✅ `AWSDeploymentConfig` class (renamed from `DeploymentConfig`)
- ✅ `AzureDeploymentConfig` class (all Azure-specific parameters)
- ✅ `DependencyChecker` updated for both AWS CLI and Azure CLI
- ✅ Backward compatibility maintained

### 2. Configuration Collection (100%)
- ✅ `ConfigurationPrompt.__init__()` accepts `cloud_provider` parameter
- ✅ `collect_configuration()` method for AWS (existing)
- ✅ `collect_azure_configuration()` method for Azure (NEW - 245 lines)

**Azure Configuration Prompts:**
- Azure subscription ID (auto-detected via `az account show`)
- Azure location/region
- Resource group name
- AKS cluster configuration (name, K8s version, VM size, node count)
- Autoscaling settings
- n8n configuration (namespace, hostname, persistence size, timezone)
- Encryption key (generated or provided)
- Database type (SQLite or PostgreSQL Flexible Server)
- TLS/HTTPS configuration
- Basic authentication
- Configuration summary display

### 3. Main Function Updates (50%)
- ✅ Cloud provider selection logic in `main()`
- ✅ Dynamic dependency checking based on provider
- ✅ Provider-specific banner display
- ⏳ Needs: Provider-specific configuration collection call
- ⏳ Needs: Provider-specific deployment flow routing

## 🚧 What Still Needs Implementation

### 1. FileUpdater Azure Support

Add Azure-specific Terraform tfvars creation:

```python
# In FileUpdater class, add:

def create_terraform_tfvars_azure(self, config: AzureDeploymentConfig):
    """Create terraform.tfvars for Azure AKS infrastructure deployment"""
    tfvars_file = self.base_dir / "infrastructure" / "azure" / "terraform" / "terraform.tfvars"

    lines = [
        "# Auto-generated by setup.py - N8N Azure AKS Infrastructure",
        f'azure_subscription_id = "{config.azure_subscription_id}"',
        f'azure_location        = "{config.azure_location}"',
        f'resource_group_name   = "{config.resource_group_name}"',
        f'project_tag           = "n8n-app"',
        '',
        "# AKS Cluster",
        f'cluster_name       = "{config.cluster_name}"',
        f'kubernetes_version = "{config.kubernetes_version}"',
        f'node_vm_size       = "{config.node_vm_size}"',
        f'node_count         = {config.node_count}',
        f'node_min_count     = {config.node_min_count}',
        f'node_max_count     = {config.node_max_count}',
        f'enable_auto_scaling = {str(config.enable_auto_scaling).lower()}',
        '',
        "# Application",
        f'n8n_host          = "{config.n8n_host}"',
        f'n8n_namespace     = "{config.n8n_namespace}"',
        f'n8n_protocol      = "{config.n8n_protocol}"',
        f'timezone          = "{config.timezone}"',
        f'n8n_persistence_size = "{config.n8n_persistence_size}"',
        '',
        "# Database",
        f'database_type = "{config.database_type}"',
    ]

    if config.database_type == "postgresql":
        lines.extend([
            f'postgres_sku                = "{config.postgres_sku}"',
            f'postgres_storage_gb         = {config.postgres_storage_gb}',
            f'postgres_high_availability  = {str(config.postgres_high_availability).lower()}',
        ])

    lines.extend([
        '',
        "# Optional Features",
        f'enable_nginx_ingress = {str(config.enable_nginx_ingress).lower()}',
        f'enable_basic_auth    = {str(config.enable_basic_auth).lower()}',
        f'enable_cert_manager  = {str(config.enable_cert_manager).lower()}',
    ])

    tfvars_file.parent.mkdir(parents=True, exist_ok=True)
    tfvars_file.write_text('\n'.join(lines) + '\n')
    print(f"{Colors.OKGREEN}✓ Created {tfvars_file}{Colors.ENDC}")
```

### 2. Azure Terraform Deployment

Add Azure Terraform wrapper functions (similar to existing AWS ones):

```python
def deploy_azure_terraform(config: AzureDeploymentConfig, terraform_dir: Path) -> bool:
    """Deploy Azure infrastructure with Terraform"""
    print(f"\n{Colors.HEADER}Phase 1: Terraform Infrastructure Deployment{Colors.ENDC}")
    print("=" * 60)

    # Initialize Terraform
    print(f"\n{Colors.HEADER}Initializing Terraform...{Colors.ENDC}")
    result = subprocess.run(
        ['terraform', 'init'],
        cwd=terraform_dir,
        capture_output=True,
        text=True
    )

    if result.returncode != 0:
        print(f"{Colors.FAIL}✗ Terraform init failed{Colors.ENDC}")
        print(result.stderr)
        return False

    print(f"{Colors.OKGREEN}✓ Terraform initialized{Colors.ENDC}")

    # Plan
    print(f"\n{Colors.HEADER}Planning infrastructure...{Colors.ENDC}")
    result = subprocess.run(
        ['terraform', 'plan', '-out=tfplan'],
        cwd=terraform_dir,
        capture_output=False  # Show output
    )

    if result.returncode != 0:
        return False

    # Apply
    print(f"\n{Colors.HEADER}Deploying infrastructure (this may take 10-15 minutes)...{Colors.ENDC}")
    result = subprocess.run(
        ['terraform', 'apply', 'tfplan'],
        cwd=terraform_dir,
        capture_output=False
    )

    if result.returncode != 0:
        print(f"{Colors.FAIL}✗ Terraform apply failed{Colors.ENDC}")
        return False

    print(f"{Colors.OKGREEN}✓ Azure infrastructure deployed{Colors.ENDC}")

    # Get kubeconfig
    print(f"\n{Colors.HEADER}Configuring kubectl...{Colors.ENDC}")
    subprocess.run([
        'az', 'aks', 'get-credentials',
        '--resource-group', config.resource_group_name,
        '--name', config.cluster_name,
        '--overwrite-existing'
    ])

    return True
```

### 3. Azure Helm Deployment

Add Azure Helm deployment logic:

```python
def deploy_azure_helm(config: AzureDeploymentConfig, charts_dir: Path, encryption_key: str) -> bool:
    """Deploy n8n to Azure AKS via Helm"""
    print(f"\n{Colors.HEADER}Phase 2: Helm Application Deployment{Colors.ENDC}")
    print("=" * 60)

    # Get LoadBalancer IP from Azure
    print(f"\n{Colors.HEADER}Getting LoadBalancer IP...{Colors.ENDC}")
    result = subprocess.run([
        'az', 'network', 'public-ip', 'show',
        '--resource-group', config.resource_group_name,
        '--name', f'{config.resource_group_name}-lb-pip',  # Adjust based on Terraform output
        '--query', 'ipAddress',
        '-o', 'tsv'
    ], capture_output=True, text=True)

    loadbalancer_ip = result.stdout.strip() if result.returncode == 0 else None

    # Prepare Helm values
    helm_values = {
        'image.tag': 'latest',
        'ingress.enabled': str(config.enable_nginx_ingress).lower(),
        'ingress.host': config.n8n_host,
        'persistence.enabled': 'true',
        'persistence.size': config.n8n_persistence_size,
        'persistence.storageClass': 'managed-premium',  # Azure storage class
        'env.N8N_HOST': config.n8n_host,
        'env.N8N_PROTOCOL': config.n8n_protocol,
        'env.GENERIC_TIMEZONE': config.timezone,
        'env.TZ': config.timezone,
    }

    # Build helm command
    helm_cmd = [
        'helm', 'upgrade', '--install', 'n8n',
        str(charts_dir / 'n8n'),
        '--namespace', config.n8n_namespace,
        '--create-namespace',
        '--values', str(charts_dir / 'n8n' / 'values-azure.yaml'),
        '--set-string', f'config.encryptionKey={encryption_key}'
    ]

    # Add other values
    for key, value in helm_values.items():
        helm_cmd.extend(['--set-string', f'{key}={value}'])

    # Deploy
    print(f"\n{Colors.HEADER}Deploying n8n via Helm...{Colors.ENDC}")
    result = subprocess.run(helm_cmd, capture_output=False)

    if result.returncode != 0:
        print(f"{Colors.FAIL}✗ Helm deployment failed{Colors.ENDC}")
        return False

    print(f"{Colors.OKGREEN}✓ n8n deployed to Azure AKS{Colors.ENDC}")

    # Show access information
    if loadbalancer_ip:
        print(f"\n{Colors.OKGREEN}n8n URL: {config.n8n_protocol}://{config.n8n_host}{Colors.ENDC}")
        print(f"{Colors.OKCYAN}LoadBalancer IP: {loadbalancer_ip}{Colors.ENDC}")
        print(f"\n{Colors.WARNING}Configure DNS: Point {config.n8n_host} to {loadbalancer_ip}{Colors.ENDC}")

    return True
```

### 4. Update main() Function

Modify the main() function to route to Azure deployment:

```python
# In main(), after configuration collection:

# Collect configuration based on cloud provider
prompt = ConfigurationPrompt(cloud_provider=cloud_provider)

if cloud_provider == "azure":
    config = prompt.collect_azure_configuration()

    # Azure deployment flow
    terraform_dir = script_dir / "infrastructure" / "azure" / "terraform"
    charts_dir = script_dir / "charts"

    # Create Terraform tfvars
    file_updater = FileUpdater(script_dir)
    file_updater.create_terraform_tfvars_azure(config)

    # Deploy infrastructure
    if not deploy_azure_terraform(config, terraform_dir):
        print(f"{Colors.FAIL}Deployment failed{Colors.ENDC}")
        sys.exit(1)

    # Deploy application
    if not deploy_azure_helm(config, charts_dir, config.n8n_encryption_key):
        print(f"{Colors.FAIL}Deployment failed{Colors.ENDC}")
        sys.exit(1)

    print(f"\n{Colors.OKGREEN}✓ Azure AKS deployment complete!{Colors.ENDC}")

else:  # AWS
    config = prompt.collect_configuration()
    # Existing AWS deployment flow...
```

### 5. Azure Teardown Support

Add Azure-specific teardown class (similar to `EKSTeardown`):

```python
class AKSTeardown:
    """Handles Azure AKS deployment teardown"""

    def __init__(self, config: AzureDeploymentConfig, script_dir: Path):
        self.config = config
        self.script_dir = script_dir
        self.terraform_dir = script_dir / "infrastructure" / "azure" / "terraform"

    def phase1_helm_releases(self) -> bool:
        """Remove Helm releases"""
        print(f"\n{Colors.HEADER}Phase 1: Removing Helm Releases{Colors.ENDC}")
        # Similar to AWS teardown...

    def phase2_kubernetes_resources(self) -> bool:
        """Remove Kubernetes resources"""
        print(f"\n{Colors.HEADER}Phase 2: Removing Kubernetes Resources{Colors.ENDC}")
        # Similar to AWS teardown...

    def phase3_terraform_destroy(self) -> bool:
        """Destroy Azure infrastructure"""
        print(f"\n{Colors.HEADER}Phase 3: Destroying Azure Infrastructure{Colors.ENDC}")
        result = subprocess.run(
            ['terraform', 'destroy', '-auto-approve'],
            cwd=self.terraform_dir
        )
        return result.returncode == 0

    def phase4_keyvault_cleanup(self) -> bool:
        """Clean up Azure Key Vault soft-deleted items"""
        print(f"\n{Colors.HEADER}Phase 4: Key Vault Cleanup{Colors.ENDC}")
        # Azure Key Vault has soft-delete, may need purging
        return True
```

## 📋 Implementation Checklist

- [ ] Add `FileUpdater.create_terraform_tfvars_azure()` method
- [ ] Add `deploy_azure_terraform()` function
- [ ] Add `deploy_azure_helm()` function
- [ ] Update `main()` to call `collect_azure_configuration()` for Azure
- [ ] Update `main()` to route to Azure deployment flow
- [ ] Add `AKSTeardown` class
- [ ] Update teardown handling in `main()` for Azure
- [ ] Test full Azure deployment workflow
- [ ] Test full Azure teardown workflow
- [ ] Update help text and documentation

## 🧪 Testing Plan

1. **AWS Flow (Regression Test)**
   ```bash
   python setup.py --cloud-provider aws
   # Verify existing AWS deployment still works
   ```

2. **Azure Flow (New Feature)**
   ```bash
   python setup.py --cloud-provider azure
   # Verify Azure deployment completes
   ```

3. **Interactive Selection**
   ```bash
   python setup.py
   # Select Azure from menu
   # Verify full deployment
   ```

4. **Teardown Testing**
   ```bash
   python setup.py --cloud-provider azure --teardown
   # Verify clean destruction
   ```

## 📚 Current Status

**Line Count:** 3,198 lines (from ~2,900 before multi-cloud)

**Completion:**
- Configuration: 100% ✅
- Deployment: 40% 🚧
- Teardown: 10% 🚧
- Testing: 0% ⏳

**Estimated Remaining Work:** ~400-500 lines of code

## 🎯 Alternative Approach

If unified setup.py becomes too complex, consider splitting into:

```
scripts/
  ├── setup_aws.py      # AWS EKS deployment
  ├── setup_azure.py    # Azure AKS deployment
  └── shared/
      ├── config.py     # Shared configuration classes
      ├── prompts.py    # Shared prompt utilities
      └── colors.py     # Shared color utilities
```

This provides better separation of concerns while sharing common code.

## 💡 Quick Start for Completion

To complete the implementation, copy the code snippets above into setup.py in this order:

1. Add `create_terraform_tfvars_azure()` to `FileUpdater` class
2. Add `deploy_azure_terraform()` function before `main()`
3. Add `deploy_azure_helm()` function before `main()`
4. Add `AKSTeardown` class before `main()`
5. Update `main()` function with Azure routing logic

Then test with:
```bash
python setup.py --cloud-provider azure
```

---

**Last Updated:** October 18, 2025
**Status:** Foundation complete, deployment logic in progress
**Next Milestone:** Complete Azure Terraform + Helm deployment functions
